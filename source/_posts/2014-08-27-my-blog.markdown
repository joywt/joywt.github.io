---
layout: post
title: "内存管理和ARC"
date: 2014-08-27 20:32:08 +0800
comments: true
categories: 
---

*注释：本文内容大多来自《Objective-C高级编程 iOS和OS X多线程和内存管理》这本书*

### 内存管理

#### 内存管理的思考方式
* 自己生成的对象，自己持有
* 非自己生成的对象，自己也能持有
* 不再需要自己持有的对象时释放
* 非自己持有的对象无法释放

对象操作与Objective-C 方法的对应表：

对象操作			| Objective-C 方法
--------------	| ---------------
生成并持有对象	| alloc/new/copy/mutableCopy 等方法
持有对象			| retain 方法
释放对象			| release 方法
废弃对象			| dealloc 方法

具体方法的事例和实现不在这里陈述，感兴趣的可以购买图书翻看。解释一下“非自己生成的对象，自己也能持有”，华丽的语言比不过代码两行（非ARC）：

    /**
     *  取得非自己生成并持有的对象。对象存在，但自己不持有
     */
    id obj = [NSMutableArray array];
    /**
     *  自己持有对象
     */
    [obj retain];
    
### ARC

#### 所有权修饰符
ARC有效时，id类型和对象类型必须附加所有权修饰符。所有权修饰符一共有4种。

* __strong 修饰符
* __weak 修饰符
* __unsafe_unretained 修饰符
* __autoreleasing 修饰符

##### 1. __strong 修饰符
id 和对象类型在没有明确指定所有权修饰符时，默认为 __strong 修饰符，下面两行代码相同：

	id obj = [[NSObject alloc]init];
	id __strong obj = [[NSObject alloc]init];
对象类型包括自己生成的对象和非自己生成的对象，比如：

	id __strong obj = [NSMutableArray array];
苹果宣称：通过 __strong 修饰符，不必再次键入 retain 或者 release,完美地满足了“内存管理的思考方式”，通过下面的代码来展示：

	id __strong obj0 = [[NSObject alloc] init];/*** obj0 持有对象A的强引用 ***/
    id obj1 = [[NSObject alloc] init];/*** obj1 持有对象B的强引用 ***/
    id obj2 = nil;
    
    obj1 = obj0;
    /**
     *  obj1 持有 obj0 赋值的对象B的强引用
     *  因为obj1 被赋值，所以原来持有对象B的强引用失效。
     *  对象B的所有者不存在，因此废弃对象B、
     *
     *  此时，对象A的强引用变量为 obj1 和 obj0
     */
    obj2 = obj1;
    /**
     *
     *
     *  此时 对象A的强引用变量为 obj0 ，obj1 ，obj2
     *
     *
     */
    obj1 = nil; /** obj1对A的强引用失效 **/
    obj2 = nil; /** obj2对A的强引用失效 **/
    obj0 = nil; /** obj0对A的强引用失效 **/
    /*
     * 对象B的所有者不存在，废弃对象B。
     *
     */

##### 2. __weak 修饰符
__weak 修饰符可解决内存管理中必然发生的“循环引用”的问题。下面代码展示一个循环引用。

	@interface Test : NSObject
	{
    	id obj_;
	}
	-(void)setObject:(id)obj;
	@end

	@implementation Test
	- (id)init
	{
   		self = [super init];
    	if (self) {
        
    }
    	return self;
	}
	-(void) setObject:(id)obj{
    	obj_ = obj;
	}
	@end
	
	{
		id test0 = [[Test alloc] init]; /* 对象 A */
    	id test1 =[[Test alloc] init]; /* 对象 B */
    	/**
    	 *  Test对象A的obj_成员变量持有Test对象B的强引用
    	 *  此时持有对象B的强引用对象为 A 的obj_ 和 test1
     	 */
    	[test0 setObject:test1];
   	   	/**
     	 *  Test对象B的obj_成员变量持有Test对象A的强引用
     	 *  此时持有对象A的强引用对象为 B 的obj_ 和 test0
     	 */
    	[test1 setObject:test0];
	}
	test0和test1超出作用域，强引用失效。此时持有Test对象A的强引用为Test对象B的obj_。持有	Test对象B的强引用为Test对象A的obj_。内存泄露
	
因为带__weak修饰符的变量（弱引用）不持有对象，所以在超出其变量作用域是，对象释放。那么此时引用__weak即可解决这个问题，

	@interface Test : NSObject
	{
    	id __block obj_;
	}
	
##### __unsafe_unretained 修饰符

__unsafe_unretained修饰符正如其名 unsafe 所示，是不安全的所有权修饰符。尽管ARC式的内存管理是编译器的工作，但 __unsafe_unretained 修饰的变量不属于编译器的内存管理对象。

__unsafe_unretained和__weak一样，自己生成并持有的对象不能被自己持有。

	id __unsafe_unretained obj = [[NSObject alloc] init];
这里会报错误提示“assigning retained obj to unsafe_unretained variable”。下面来看看 __unsafe_unretained 和 __weak 的差异

	id __unsafe_unretained objA = nil;
	{
    id objB = [[NSObject alloc] init];
    objA = objB;
    NSLog(@"A : %@",objA);
    }
    NSLog(@"A2 : %@",objA);
    
输出你会发现两次输出内容一样。但是 objB 变量在超出其作用域，强引用失效，自动释放持有的对象。A2输出objA变量表示的对象已经被废弃（悬垂指针）！错误访问！ 也就是说最后一行输出正常运行只是碰巧而已。

##### __autorelease 修饰符
ARC 中 autorelease 和 NSAutoreleasePool 也不能使用，但可以这样写：

	@autoreleasepool {
        id __autoreleasing obj = [[NSObject alloc] init];
    }
   
ARC 下__autoreleasing来代替 autorelease方法，即对象被注册到 autoreleasepool。下面还有几种情况生成的对象会注册到 autoreleasepool。init 方法返回值的对象不注册到 autoreleasepool。

@autoreleasepool下 __strong 类型非自己生成自己持有的对象

	@autoreleasepool {
        id  obj = [NSMutableArray array];
    }

对象作为函数返回值，因对象变量返回时超出其作用域，编译器会自动把对象注册到 autoreleasepool。

	-(id)array{
    return [[NSMutableArray alloc] init];
	}
	
__weak 修饰符的变量持有的对象必定要注册到 autoreleasepool。

#### ARC 规则
* 不能使用 retain/release/retainCount/autorelease
* 不能使用 NSAllocateObject/NSDeallocateObject
* 须遵守内存管理的方法命名规则
* 不要显示的调用dealloc
* 使用 @autorelease 块替代 NSAutoreleasePool
* 不能使用区域（NSZone）
* 对象型变量不能作为C语言结构体（struct/union）的成员
* 显示转换 “id” 和 “void”

下面解释部分项

ARC下遵守内存管理的方法命名规则中一个很严格的 “init”，以init开始的方法需返回一个对象。如下：

	-(id)initWithObject:(id)obj;
	
对象型变量不能作为C语言结构体（struct/union）的成员，下面代码会引起编译错误。

	struct Data{
        NSMutableArray *array;
    };
错误描述：ARC forbids Objective-C objs in structs or unious

##### 显示转换 “id” 和 “void”
id 型或对象型变量赋值给 void * 或者逆向赋值时都需要进行特定的转换。如果只想单纯地赋值，则可以使用“__bridge转换”。

	id obj = [[NSObject alloc] init];
    void *p = (__bridge void *)obj;
    id o = (__bridge id)p;
   
像这样，通过 “__bridge 转换”，id 和 void * 就能够互相转换。__bridge 转换中还有另外两种转换，分别是 “__bridge_retained 转换” 和 “__bridge_transfer 转换”

	id obj = [[NSObject alloc] init];
    void *p = (__bridge_retained void *)obj;
    
__bridge_retained 转换可使要转换赋值的变量也持有所赋值的对象。__bridge_retained 执行了 retain。__bridge_transfer 执行 __bridge_retained 相反的动作，__bridge_retained 转换与 retain 类似，那么 __bridge_transfer 转换与 release 类似。

	id obj = [[NSObject alloc] init];
    void *p = (__bridge_retained void *)obj;
    (void)(__bridge_transfer id)p;
    
#### 属性
ARC有效时，属性声明与所有权修饰符的对应关系

属性声明的属性			| 所有权修饰符
----------------------	| ----------------------
assign					| __unsafe__unretained
copy					| __strong
retain					| __strong
strong					| __strong
unsafe_unretained		| __unsafe__unretained
weak					| __weak

